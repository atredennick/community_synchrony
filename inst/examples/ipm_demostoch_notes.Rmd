---
output: pdf_document
---

Example code for estimating covariance between size-classes. Based on equation 10.2.5 in Steve's book:

$$
Cov[n_{i}(t+1)n_{j}(t+1)] = -h^{2} \sum_{k} n_{k}(t)P(z_{i},z{k})P(z_{j},z{k})
$$

where, in our case (*I think*), $P()$ is the survival$\times$growth kernal. 

Here is the proposed code:

```{r covcode, eval=FALSE}
####
##  Define a function that returns P(z_{i},z{k})*P(z_{j},z{k}) for all i,j combos
####
# X is one column (k) of the survivalXgrowth kernal
# pop_vector is the population vector whose elements are actual numbers of individuals
get_cov <- function(X, pop_vector){
  pairs <- expand.grid(X, X)
  pairs$tag <- pairs[,1] - pairs[,2]
  pairs$multi <- pairs[,1]*pairs[,2]*pop_vector
  return(pairs$multi)
}  

####
##  Apply the function over each column
####
test <- apply(K.matrix, MARGIN = 2, FUN = "get_cov", 
              pop_vector=(nt[[doSpp]]*h[doSpp]))

####
##  Create a tag for identifying the focal i
####
mat_dim <- sqrt(dim(test)[1])
test <- as.data.frame(test)
test$tag <- rep(c(1:mat_dim), each=mat_dim)

####
##  Loop over each i and calculate the covariance with each j (vectorized)
####
cov_str <- matrix(ncol=mat_dim, nrow=mat_dim)
for(do_i in 1:mat_dim){
  tmp <- subset(test, tag==do_i) #subset out the focal i
  rmtmp <- which(colnames(tmp)=="tag") #get rid of id column
  # Sum over k columns
  cov_str[do_i,] <- (-h[doSpp]^2) * apply(tmp[,-rmtmp], MARGIN = 2, FUN = "sum")
}

####
##  Make the matrix positive definite by setting i=j diagonals to 1
####
diag(cov_str) <- 1

####
##  Feed into Poisson random vector generator...
####
```

This should result in a matrix the same dimensions as $P()$ where each $i,j$ column is the appropriate covariance.

### Generate correlated Poisson vector
From Yahav and Shmueli (2007; http://arxiv.org/pdf/0710.5670.pdf), here is a proposal for generating the poisson random vector with the covariance matrix.

```{r poisson, echo=TRUE, eval=TRUE}
####
##  Define function
####
# Generate a p-dimensional Poisson
# p = the dimension of the distribution
# samples = the number of observations
# R = correlation matrix p X p
# lambda = rate vector p X 1
library(MASS)
GenerateMultivariatePoisson<-function(pD, samples, R, lambda){
  normal_mu=rep(0, pD)
  normal = mvrnorm(samples, normal_mu, R)
  pois = normal
  p=pnorm(normal)
  for (s in 1:pD){pois[s]=qpois(p[s], lambda[s])}
  return(pois)
}

####
##  Example
####
pD = 2
samples = 1
R = matrix(data = c(1,0.1,
                    0.8,1), ncol=2, nrow=2)
lambda = c(0.8, 0.3)
GenerateMultivariatePoisson(pD = pD, samples = samples, R = R, lambda = lambda)
```

### Example
```{r example, echo=TRUE, eval=FALSE}
####
##  Define multivariate Poisson functions
####
# Function to get all possible pairs for a column of the iteration matrix
get_pairs <- function(X, pop_vector){
  pairs <- expand.grid(X, X)
  pairs$multi <- pairs[,1]*pairs[,2]*pop_vector
  return(pairs$multi)
} 

# Apply the 'get_pairs' function across all columns of the iteration matrix
# and calculate equation 10.2.5
get_cov <- function(K){
  test <- apply(K, MARGIN = 2, FUN = "get_pairs", 
                pop_vector=(nt[[doSpp]]))
  mat_dim <- sqrt(dim(test)[1])
  test <- as.data.frame(test)
  test$tag <- rep(c(1:mat_dim), each=mat_dim)
  cov_str <- matrix(ncol=mat_dim, nrow=mat_dim)
  for(do_i in 1:mat_dim){
    tmp <- subset(test, tag==do_i) #subset out the focal i
    rmtmp <- which(colnames(tmp)=="tag") #get rid of id column
    # Sum over k columns
    cov_str[do_i,] <- (-h[doSpp]^2) * apply(tmp[,-rmtmp], MARGIN = 2, FUN = "sum")
  }
  diag(cov_str) <- 1
  return(cov_str)
}

# Get a correlated Poisson vector based on the covariance and population vector
GenerateMultivariatePoisson<-function(pD, samples, R, lambda){
  normal_mu=rep(0, pD)
  normal = mvrnorm(samples, normal_mu, R)
  pois = normal
  p=pnorm(normal)
  for (s in 1:pD){pois[s]=qpois(p[s], lambda[s])}
  return(pois)
}

####
##  Run the model... (there would be more code here, obviously)
####
# IPM code above here...
# Leading to looping over species...
# And projecting the population from nt -> new.nt
for(doSpp in 1:Nspp){  
    if(cover[doSpp]>0){    
      # make kernels and project
      K.matrix=make.K.matrix(v[[doSpp]],WmatG[[doSpp]],WmatS[[doSpp]],
                             Rpars,rpa,Gpars,Spars,doYear,doSpp)  
      covmat <- get_cov(K=K.matrix)
      new.nt[[doSpp]] <- GenerateMultivariatePoisson(pD = length(nt[[doSpp]]),
                                  samples = 1,
                                  R = covmat,
                                  lambda = K.matrix%*%nt[[doSpp]])
      sizeSave[[doSpp]][,i]=new.nt[[doSpp]]/sum(new.nt[[doSpp]])  
    }    
  } # next species
```

And this seems to work. Not only do we not get extinctions, but synchrony of population growth ratee is 0.33, which is exactly as expected by theory: 1/S = 1/3 = 0.33.

![Example IPM simulation for Idaho (ARTR set to 0) with demographic stochasticity only.](idaho_demographic_stoch.pdf)

